def create_oscillatory_behavior(Amplitudes, Frequencies, Time):
	import numpy as np
	
	assert len(Amplitudes) == len(Frequencies),"Amplitudes and Frequencies must be the same length."
	assert len(Amplitudes) > 0, "Amplitudes/Frequencies must not be empty."
	assert 0 not in Frequencies, "Frequencies must be nonzero."
	assert sum(Amplitudes) <= np.pi/2, "Physiologically out of range for our interest."
	assert Time[1] - Time[0] >= 0.001, "Time step must be sufficiently small (>= 0.001)"
	Angle = np.zeros(len(Time))
	AngularVelocity = np.zeros(len(Time))
	AngularAcceleration = np.zeros(len(Time))
	for i in range(len(Amplitudes)):
		if (i%2 ==0):
			Angle += Amplitudes[i]*np.cos(2*np.pi*Frequencies[i]*Time)
			AngularVelocity +=  -2*np.pi*Frequencies[i]*Amplitudes[i]*np.sin(2*np.pi*Frequencies[i]*Time)
			AngularAcceleration += -4*np.pi**2*Frequencies[i]**2*Amplitudes[i]*np.cos(2*np.pi*Frequencies[i]*Time)
		else:
			Angle += Amplitudes[i]*np.sin(2*np.pi*Frequencies[i]*Time)
			AngularVelocity += 2*np.pi*Frequencies[i]*Amplitudes[i]*np.cos(2*np.pi*Frequencies[i]*Time)
			AngularVelocity += -4*np.pi**2*Frequencies[i]**2*Amplitudes[i]*np.sin(2*np.pi*Frequencies[i]*Time)
	return([Angle, AngularVelocity, AngularAcceleration])

def one_dof_target_trajectory_task_nonlinear(KinematicArrays, Time, **kwargs):
	"""
	# One DOF Target Trajectory Task - NONLINEAR
	# with Four Muscles
	# August 2016 - USC
	# Daniel A Hagen

	NOTE: This program uses CVXOPT to do quadratic programming to find the optimal activation.

	This function will create activation level plots for a given prescribed trajectory and timecourse for a 
	one DOF system with 4 muscles. You may change the maximum force output of each muscle, but the actual 
	force output will be determined by the muscle length and the muscle velocity at that timestep based on
	a f-l and f-v relationship. You may also change the moment are values for each muscle (must be constant
	in this implementation), as well as the optimal fiber lengths. The mass and length of the rod are set 
	10 and 1 respectively, but can also be changed. This program uses scipy.optimize.linprog to find the 
	activation levels constrained by a Cost function. This is defaulted to the sum of the activations but can
	also be changes using **kwargs. 

	KinematicArrays must be a list of the form [AngleArray, AngularVelocityArray, AngularAccelerationArray].
	Time must have the same length as each kinematic array and must have a sufficiently small time step
	(>= 0.001). 

	**kwargs
	~~~~~~~~~~~~~~~~~~

	Mass and LinkLength can be changed but must be positive and nonzero. Defaults are set to 10 and 1,
	respectively.

	MomentArms must be an N x 4 Matrix, where each row represents the moment arm values of a separate
	trial. This function will return a plot of all activation levels on the same figure. None of the
	entries in Moments arms may be zero or negative. Default is set to np.matrix([1,1,-1,-1])

	OptimalLengths must be a 1 x 4 Matrix, where all entries must be nonzero and positive. Default is 
	set to np.matrix([10,10,10,10])

	OptimalForces must be a 1 x 4 Matrix, where all entries must be nonzero and positive. Default is 
	set to np.matrix([3500,3500,3500,3500])

	Cost must be an numpy array in order to the scipy.optimize.linprog to work. It must also be of 
	shape (4,) and must have nonzero entries. Default is set to np.array([1,1,1,1])

	plotFLV must be a boolean. If set to True, this will plot the F-L, F-V and F-L-V plots (surfaces). 
	Default is set to False.

	plotTorques must be a boolean. If set to True, this will plot the torques generated by each muscle 
	during the motion. Default is set to False.

	plotMuscleForces must be a boolean. If set to True, this will plot the forces generated by each muscle 
	during the motion. Default is set to False.

	plotMaxTorques must be a boolean. If set to True, this will plot the maximum torques each muscle 
	can produce during the motion. Default is set to False.
	~~~~~~~~~~~~~~~~~~
	"""

	import numpy as np 
	from scipy.optimize import linprog
	import matplotlib.pyplot as plt 
	import sympy as sp 
	from mpl_toolkits.mplot3d import Axes3D
	from matplotlib import cm
	import cvxopt as co

	Mass = kwargs.get('Mass',10)
	LinkLength = kwargs.get('LinkLength',1)
	MomentArms = np.matrix(kwargs.get('MomentArms',np.matrix([1,1,-1,-1])))
	OptimalLengths = np.matrix(kwargs.get('OptimalLengths',np.matrix([10,10,10,10])))
	OptimalForces = np.matrix(kwargs.get('OptimalForces',np.matrix([3500,3500,3500,3500])))
	Cost = kwargs.get('Cost',np.array([1,1,1,1]))
	plotFLV = kwargs.get('plotFLV', False)
	plotTorques = kwargs.get('plotTorques', False)
	plotMuscleForces = kwargs.get('plotMuscleForces', False)
	plotMaxTorques = kwargs.get('plotMaxTorques', False)

	assert Mass > 0, "Mass must be greater than zero"
	assert LinkLength > 0, "LinkLength must be greater than zero"
	assert np.shape(KinematicArrays)[0] == 3, "KinematicArray must be a 3xN array"
	assert np.shape(KinematicArrays)[1]==len(Time), "Time must be the same length as KinematicArrays"
	assert Time[1]-Time[0] >= 0.001, "Time step must be sufficiently small (>= 0.001)"
	assert np.shape(MomentArms)[1] == 4, "MomentArms must be a Nx4 matrix (Use additional rows for additional MA values)"
	assert 0 not in MomentArms, "MomentArms must have all nonzero entries"
	assert np.shape(OptimalLengths) == (1,4), "OptimalLengths must be a 1x4 matrix"
	assert 0 not in OptimalLengths, "OptimalLengths must have all nonzero entries"
	assert False not in (OptimalLengths>0), "OptimalLengths must have all positive entries"
	assert np.shape(OptimalForces) == (1,4), "OptimalForces must be a 1x4 matrix"
	assert 0 not in OptimalForces, "OptimalForces must have all nonzero entries"
	assert False not in (OptimalForces>0), "OptimalForces must have all positive entries"
	assert np.shape(Cost) == (4,), "Cost must be a 1x4 array"
	assert 0 not in Cost, "Cost must have all nonzero entries"
	assert type(Cost) == np.ndarray, "In order to use linprog(), Cost must be a numpy array"
	assert type(plotFLV) == bool, "plotFLV must be a boolean to determine if you want to plot FLV or not"
	assert type(plotTorques) == bool, "plotTorques must be a boolean to determine if you want to plot torque levels"
	assert type(plotMuscleForces) == bool, "plotMuscleForces must be a boolean to determine if you want to plot muscle force levels"
	assert type(plotMaxTorques) == bool, "plotMaxTorques must be a boolean to determine if you want to plot maximum torques each muscle can produce"

	# Define remaining parameters
	Angle, AngularVelocity, AngularAcceleration = KinematicArrays[0],KinematicArrays[1],KinematicArrays[2]
	Inertia = (1/3)*Mass*LinkLength**2
	TorqueDueToGravity = [-0.5*Mass*9.8*LinkLength*np.cos(float(theta)) for theta in Angle]
	SumOfMuscleTorques = [Inertia*float(AngularAcceleration[i]) - TorqueDueToGravity[i] for i in range(len(Time))]
	Epsilon = 0.01	

	def force_length_curve(NormalizedMuscleLength):
		if NormalizedMuscleLength < -0.5:
			result = 0
		elif NormalizedMuscleLength < 0:
			sigma = 1
			result = (1 + (1/(np.exp(1/(8*sigma**2))-1)))*np.exp(-NormalizedMuscleLength**2/(2*sigma**2)) - (1/(np.exp(1/(8*sigma**2))-1))
			#1 - (NormalizedMuscleLength/0.5)**2
		else:
			sigma = .10 #(0.036191/8)**.5
			result = np.exp(-NormalizedMuscleLength**2/(8*sigma**2))
		#else: 
		#	result = 2.4*NormalizedMuscleLength**2
		return(result)

	#force_length_curve = lambda x: 1-(x/0.5)**2 if np.abs(x)<=0.5 else 0

	def passive_force_length_curve(NormalizedMuscleLength):
		PassiveAmplitudeAtZero = 0.01
		PassiveConstant = 9
		result = PassiveAmplitudeAtZero*np.exp(PassiveConstant*NormalizedMuscleLength)
		return(result)

	def force_velocity_curve(NormalizedMuscleVelocity,b):
		"""
		NormalizedMuscleVelocity is a scalar and b is a coefficient
		that can be changed to adjust the shape of the curve.
		"""
		if NormalizedMuscleVelocity < -5:
			result = 0
		elif NormalizedMuscleVelocity < 0:
			result = (1 + NormalizedMuscleVelocity/5)/(b - NormalizedMuscleVelocity)
		else:
			result = (1.8 - 0.8*np.exp(-(b+5)*NormalizedMuscleVelocity/(4*b**2)))
		return(result)

	def maximum_muscle_force(OptimalLengths, Angle, AngularVelocity, R, OptimalForces):
		"""
		OptimalLengths must be a 1X4 Matrix with optimal muscle lengths for 4 muscles.
		Angle should be the current angle. AngularVelocity should be the current 
		angular velocity. R is the 1X4 moment arm matrix. And OptimalForces should be
		a 4X1 matrix of forces produced by each muscle when at optimal lengths and 
		velocities.
		"""
		# Force-Length Considerations
		CurrentMuscleLengths = OptimalLengths.T - R.T*Angle
		NormalizedMuscleLengths = np.matrix([(CurrentMuscleLengths[i,0]/OptimalLengths.T[i,0])-1 for i in range(4)])
		# We subtract one from every Normalized Muscle Length to find the percentage 
		# above and below the optimal length.
		
		MaximumMuscleForce_FL = np.identity(4)*[force_length_curve(NormalizedMuscleLengths[0,i]) \
													+ passive_force_length_curve(NormalizedMuscleLengths[0,i],) \
														for i in range(4)]

		# Force-Velocity Considerations
		CurrentMuscleVelocity = -R.T*AngularVelocity
		NormalizedMuscleVelocity = [CurrentMuscleVelocity[i,0]/OptimalLengths.T[i,0] for i in range(4)]
		
		MaximumMuscleForce_FV = np.identity(4)* \
									[force_velocity_curve(NormalizedMuscleVelocity[i],1) \
										for i in range(4)]
		MaximumMuscleForce = (MaximumMuscleForce_FL+MaximumMuscleForce_FV)*[OptimalForces[0,i] for i in range(4)]
		return(MaximumMuscleForce)

	def construct_Q_matrix(weights):
		Q = 2*co.matrix(weights*np.identity(len(weights)))
		return(Q)

	def construct_G_matrix(dim):
		G = co.matrix(np.concatenate((np.identity(dim),-np.identity(dim))))
		return(G)

	def construct_h_array(dim):
		h = co.matrix(np.concatenate(([1.]*dim,[0.]*dim)),(2*dim,1))
		return(h)

	def construct_A_matrix(OptimalLengths, Angle, AngularVelocity, R, OptimalForces):
		MaximumForceMatrix = maximum_muscle_force(OptimalLengths, Angle, AngularVelocity, R, OptimalForces)
		A = co.matrix(R*MaximumForceMatrix)
		return(A)

	def construct_b_vector(SumOfMuscleTorques, Epsilon):
		b = co.matrix(SumOfMuscleTorques+Epsilon)
		return(b)

	QWeights = [1,1,1,1]
	Q = construct_Q_matrix(QWeights)	
	p = co.matrix([0.0]*len(QWeights))
	G = construct_G_matrix(len(QWeights))
	h = construct_h_array(len(QWeights))

	# Find and print optimal solution
	def find_a_star(OptimalLengths,Angle,AngularVelocity,R,OptimalForces,SumOfMuscleTorques,Epsilon,Time):
		a = [co.solvers.qp(Q,p,G,h,construct_A_matrix(OptimalLengths, float(Angle[i]), float(AngularVelocity[i]), R, OptimalForces),construct_b_vector(SumOfMuscleTorques[i],Epsilon)) for i in range(len(Time))]
		a_star = np.matrix(np.concatenate([[np.array(a[i]['x']) for i in range(len(Time))]]))
		return(a_star)
	
	def remove_background_axes(ax):
		ax.patch.set_facecolor('none')
		ax.spines['top'].set_color('none')
		ax.spines['bottom'].set_color('none')
		ax.spines['left'].set_color('none')
		ax.spines['right'].set_color('none')
		ax.tick_params(labelcolor='none', top='off', bottom='off', left='off', right='off')

	# Plot the activation levels for each Moment Arm Matrix.
	fig1 = plt.figure()
	ax1 = fig1.gca()

	# Turn off axis lines and ticks of the big subplot
	if np.shape(MomentArms)[0] > 1: remove_background_axes(ax1)
	if plotTorques == True:
		fig2 = plt.figure()
		ax2 = plt.gca()
		if np.shape(MomentArms)[0] > 1: remove_background_axes(ax2)
	if plotMuscleForces	 == True:
		fig3 = plt.figure()
		ax3 = plt.gca()
		if np.shape(MomentArms)[0] > 1: remove_background_axes(ax3)
	if plotMaxTorques == True:
		fig4 = plt.figure()
		ax4 = plt.gca()
		if np.shape(MomentArms)[0] > 1: remove_background_axes(ax4)

	for i in range(np.shape(MomentArms)[0]):
		a_star = find_a_star(OptimalLengths,Angle,AngularVelocity,MomentArms[i,:],OptimalForces,SumOfMuscleTorques,Epsilon,Time)
		AX1 = fig1.add_subplot(np.shape(MomentArms)[0]*100 + 10 + i+1)
		AX1.plot(Time,a_star)
		AX1.set_ylabel('Muscle Activation')
		AX1.legend(['Muscle 1','Muscle 2','Muscle 3','Muscle 4'])
		if i == 0:
			AX1.set_title("F_max = [{}, {}, {}, {}]\nR = [{}, {}, {}, {}]"
					.format(OptimalForces[0,0], OptimalForces[0,1], OptimalForces[0,2], OptimalForces[0,3],\
								MomentArms[i,0],MomentArms[i,1],MomentArms[i,2],MomentArms[i,3]))
		else:
			AX1.set_title("R = [{}, {}, {}, {}]"
					.format(MomentArms[i,0],MomentArms[i,1],MomentArms[i,2],MomentArms[i,3]))
		if plotTorques == True:
			Torques = np.concatenate([MomentArms[i,:]*(maximum_muscle_force(OptimalLengths, Angle[j], \
						AngularVelocity[j], MomentArms[i,:], OptimalForces)*(np.identity(4)*np.array(a_star[j]))) for j in range(len(Time))], axis = 0)
			AX2 = fig2.add_subplot(np.shape(MomentArms)[0]*100 + 10 + i+1)
			AX2.plot(Time, Torques)
			AX2.set_ylabel('Torque from Each Muscle')
			AX2.legend(['Muscle 1','Muscle 2','Muscle 3','Muscle 4'])
			if i == 0:
				AX2.set_title("F_max = [{}, {}, {}, {}]\nR = [{}, {}, {}, {}]"
						.format(OptimalForces[0,0], OptimalForces[0,1], OptimalForces[0,2], OptimalForces[0,3],\
								MomentArms[i,0],MomentArms[i,1],MomentArms[i,2],MomentArms[i,3]))
			else:
				AX2.set_title("R = [{}, {}, {}, {}]"
						.format(MomentArms[i,0],MomentArms[i,1],MomentArms[i,2],MomentArms[i,3]))
		if plotMuscleForces	 == True:
			MuscleForces = np.concatenate([maximum_muscle_force(OptimalLengths, Angle[j], \
							AngularVelocity[j], MomentArms[i,:], OptimalForces)*(np.matrix(a_star[j]).T) \
							for j in range(len(Time))], axis = 1)
			AX3 = fig3.add_subplot(np.shape(MomentArms)[0]*100 + 10 + i+1)
			AX3.plot(Time, MuscleForces.T)
			AX3.set_ylabel('Force from Each Muscle')
			AX3.legend(['Muscle 1','Muscle 2','Muscle 3','Muscle 4'])
			if i == 0:
				AX3.set_title("F_max = [{}, {}, {}, {}]\nR = [{}, {}, {}, {}]"
						.format(OptimalForces[0,0], OptimalForces[0,1], OptimalForces[0,2], OptimalForces[0,3],\
								MomentArms[i,0],MomentArms[i,1],MomentArms[i,2],MomentArms[i,3]))
			else:
				AX3.set_title("R = [{}, {}, {}, {}]"
						.format(MomentArms[i,0],MomentArms[i,1],MomentArms[i,2],MomentArms[i,3]))
		if plotMaxTorques == True:
			MaxTorques = np.concatenate([MomentArms[i,:]*maximum_muscle_force(OptimalLengths, Angle[j], \
							AngularVelocity[j], MomentArms[i,:], OptimalForces) \
							for j in range(len(Time))], axis = 0)
			AX4 = fig4.add_subplot(np.shape(MomentArms)[0]*100 + 10 + i+1)
			AX4.plot(Time, MaxTorques)
			AX4.set_ylabel('Maximum Torques Each Muscle Can Produce')
			AX4.legend(['Muscle 1','Muscle 2','Muscle 3','Muscle 4'])
			if i == 0:
				AX4.set_title("F_max = [{}, {}, {}, {}]\nR = [{}, {}, {}, {}]"
						.format(OptimalForces[0,0], OptimalForces[0,1], OptimalForces[0,2], OptimalForces[0,3],\
								MomentArms[i,0],MomentArms[i,1],MomentArms[i,2],MomentArms[i,3]))
			else:
				AX4.set_title("R = [{}, {}, {}, {}]"
						.format(MomentArms[i,0],MomentArms[i,1],MomentArms[i,2],MomentArms[i,3]))
	if plotTorques == True: AX2.set_xlabel('Time (s)')
	if plotMuscleForces	 == True: AX3.set_xlabel('Time (s)')
	if plotMaxTorques == True: AX4.set_xlabel('Time (s)')
	ax1.set_xlabel('Time (s)')

	# Plot the F-l, F-v, and F-l-v curves if plotFLV is True
	if plotFLV == True:
		plt.figure()
		ax5 = plt.gca()
		LengthDomain = np.arange(-0.6,0.6,0.001)
		F_L_Curve = [force_length_curve(x) for x in LengthDomain]
		Passive_F_L_Curve = [passive_force_length_curve(x) for x in LengthDomain]
		plt.plot(LengthDomain,F_L_Curve)
		plt.plot(LengthDomain, Passive_F_L_Curve)
		plt.plot(LengthDomain, np.array(F_L_Curve)+np.array(Passive_F_L_Curve))
		plt.title('Force - Normalized Length Curve')
		plt.xlabel('Percent Change in Normalized Muscle Length')
		plt.ylabel('Muscle Force Percentage')

		plt.figure()
		ax6 = plt.gca()
		VelocityDomain = np.arange(-6,6,0.01)
		F_V_Curve = [force_velocity_curve(x,1) for x in VelocityDomain]
		plt.plot(VelocityDomain, F_V_Curve)
		plt.title('Force - Normalized Velocity Curve')
		plt.xlabel('Muscle Lengths per Second')
		plt.ylabel('Muscle Force Percentage')

		plt.figure()
		ax7 = plt.gca(projection = '3d')
		l = np.arange(-0.6,0.6,0.05)
		v = np.arange(-6,6,0.5)
		F_L_Curve = [force_length_curve(x) for x in l]
		Passive_F_L_Curve = [passive_force_length_curve(x) for x in l]
		F_V_Curve = [force_velocity_curve(x,1) for x in v]
		L,V = np.meshgrid(l,v)
		F = np.zeros((len(l),len(v)))
		for i in range(len(l)):
			for j in range(len(v)):
				F[j,i] = F_L_Curve[i]+Passive_F_L_Curve[i]+F_V_Curve[j]
		ax7.plot_surface(L, V, F, rstride=1, cstride=1, cmap=cm.coolwarm,
		                       linewidth=0, antialiased=False)


	plt.figure()
	ax8 = plt.gca()
	plt.plot(Time,Inertia*AngularAcceleration,'k')
	plt.xlabel('Time (s)')
	plt.ylabel('Sum of Muscle Torques')

	plt.show()
